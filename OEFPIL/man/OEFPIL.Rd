% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OEFPIL.R
\name{OEFPIL}
\alias{OEFPIL}
\title{Optimal Estimation of Parameters by Iterated Linearization}
\usage{
OEFPIL(data, form, start.val, CM, max.iter = 100, see.iter.val = F,
       save.file.name, th, signif.level, useNLS = T)
}
\arguments{
\item{data}{a data file can be any object of type \code{data.frame} with 2 named columns or \code{list} with 2 elements.}

\item{form}{an object of class \code{\link{formula}} (or one that can be coerced to that class): a symbolic description of the model to be fitted. The details of model specification are given under ‘Details’.}

\item{start.val}{starting values of estimating parameters.}

\item{CM}{a covariance matrix of \code{data} (See 'Details' for the information about required structure.).}

\item{max.iter}{maximum number of iterations.}

\item{see.iter.val}{logical. If \code{TRUE}, all the partial results of the algorithm are displayed and saved. The default value is \code{FALSE}.}

\item{save.file.name}{a name of the file for saving results. If missing, no output file is saved.}

\item{th}{a numerical value, indicating threshold necessary for the iteration stoppage.}

\item{signif.level}{a significance level for the confidence interval.}

\item{useNLS}{logical. If \code{TRUE} (the default value), function will set up starting parameters calculated by \code{\link{nlsLM}} function (nonlinear least square estimation).}
}
\value{
Returns an object of class \code{'OEPFIL'}, which is a list containing at least the following components
\itemize{
   \item \code{name_est} estimations of model parameters
   \item \code{name_upgraded.start.val} estimations of model parameters
   \item \code{it_num} number of iterations
   \item \code{CI_parameters} list of confidence intervals for estimated parameters (significance level is based on parameter signif.level)
   \item \code{logs} warnings or messages of events, which happen during the run of our function
   \item \code{name_previous} values from the previous iterative step
}
In addition we get \code{contents}, which is list of outputs as original values and entered parameters, which are usable in other estimation process.
If we set up parameter \code{useNLS} to TRUE, the start.values which enters in the estimation process will be calculated by \code{\link{nlsLM}} function. Otherwise the \code{start.values} and \code{name_upgraded.start.val} will be the same.
In the case, if we add estimated parameters with NaN, NA, Inf or -Inf, we end up with error message.
}
\description{
Function for computing optimal estimate of function parameters by iterated linearization.
}
\details{
Models for OEPFIL function are specified symbolically. A typical model has the form \code{y ~ f(x, a_1,...,a_n)}, where

 \itemize{\item \code{y} is the (numerical) response vector
           \item  \code{x} is a vector which specifies non-linear predictor  for \code{y}
           \item terms \code{a_1,...,a_n} are parameters of specified model. Function \code{f} must have continuous second partial derivatives with respect to \code{x} and parameters \code{a_1,...a_n}.}

    In the \code{data} entry of type \code{data.frame}, both columns must be named as variables in formula. The same holds for elements of \code{list}.
}
\note{
The symbol \code{pi} is reserved for Ludolf's constant. So naming one of the model´s parameters by this symbol results in constant entry of the model.
}
\examples{
## We use data file: "silica2098.RData" which is part of OEFPIL package
colnames(silica2098) <- c('x','y')

## Preparing parameter for OEFPIL function
max.iter = 100
see.iter.val = F
th = 0.001
signif.level = 0.05
useNLS = T


m.start <- 1.5
hp.start <- 0.9
alpha.start <- 5
start.val <- list(alpha=alpha.start, m=m.start, hp=hp.start)
names(start.val) <- c("alpha", "m", "hp")

## Imputed formula
form <- y ~ alpha * (x - hp) ^ m

##Now we can use OEFPIL function with defined starting values
output.form <- OEFPIL(silica2098, form, start.val,  max.iter = max.iter, see.iter.val = see.iter.val, th = th, signif.level = signif.level, useNLS = useNLS)

## Finally we can use summary function
summary(output.form)

library(MASS)
steamdata <- steam
colnames(steamdata) <- c("x","y")
n <- nrow(steamdata)
CM1 <- diag(rep(0.1,2*n))
CM2 <- diag(c(rep(0.2^2,n), rep(0.1^2,n)))

##Use of OEFPIL function with defined parameters
st1 <- OEFPIL(steamdata, y ~ b1 * 10^(b2 * x/ (b3 + x)), list(b1 = 5, b2 = 8, b3 = 200),
             CM1, useNLS = F)


## Finally we can use summary function
summary(st1)

## Plot of estimated functions
plot(output.form, signif.level = signif.level)

##Now we look at the case when algorithm of OEPFIL function does not converge
startsteam <- list(b1 = 0.1, b2 = 5, b3 = 200)
st3 <- OEFPIL(steamdata, y ~ b1 * 10^(b2 * x/ (b3 + x)), list(b1 = 0.1, b2 = 5, b3 = 200),
              CM1, useNLS = F)

##If set up useNLS = T, we get better upgraded starting values and algorithm converges
startsteam <- list(b1 = 0.1, b2 = 5, b3 = 200)
st3 <- OEFPIL(steamdata, y ~ b1 * 10^(b2 * x/ (b3 + x)), list(b1 = 0.1, b2 = 5, b3 = 200),
              CM1, useNLS = T)

}
\references{
Kubáček, L. and Kubáčková, L. (2000) \emph{Statistika a metrologie}, Univerzita Palackého v Olomouci.

   Köning1, R., Wimmer, G. and Witkovský, V. (2014) \emph{Ellipse fitting by nonlinear constraints to demodulate quadrature homodyne interferometer signals and to determine the statistical uncertainty of the interferometric phase}, Measurement Science and Technology.
}
\seealso{
\code{\link{NanoIndent.OEFPIL}} and \code{\link{nls}} for nonlinear least square package. And especially function \code{\link{nlsLM}}.
}
